# Mathematic logic

Java (version 8) library for mathematical logic expressions, or the solution of matlog labs

> [!WARNING]
> This repository is not supported anymore, and there is a bug when you use methods which works with predicates grammar,
> other parts are correct, be sure.

## About

> [!NOTE]
> If you want some information about what is this repo about, read tasks.pdf file.

## In Russian

Данный проект полностью решает 4 задачи из файла tasks.pdf, потенциально, если исправить код, если кто-то с ним далее будет работать, может решить и 5-ю.

### 1 Задача
Простой парсинг выражения, без комментриев

### 2 Задача
Нужно было добавить к строкам доказательства пояснения. Делается достаточно просто (сложность O(nlogn) в худшем случае):
1. Проверка на схему идёт за O(1).
2. Дедукция проверяется а фиг знает, я эту задачу решал года 2 назад, вроде смотрелось внутренность имликации, хранилось это чудо где-то в мапе, далее просто проходились по массиву, где в импликации последним стоит именно наше текущее выражение (проверка на равенство за глубину формулы). Т.е. работало за O(logn + k)
3. Modus ponens проверялся тоже как-то аналогично дедукции, тоже хранились Map от формул, также разбивалось по импликациям. За подробностями смотрите код в src/tasks/TaskB.java. То есть работала также за O(logn + k)

k - количество выражений, которые равны данному (на которое мы смотрим (итеративно))

### 3 Задача
Вспоминаем теорему о том, как раскрывается дедукция, осознаём её в полной мере, и начинаем писать.

### 4 Задача
Решается очень сложно, объяснять не буду, на только придумывание решения у меня ушло 2 недели каждый день по часов 6.

Есть некоторая формула: a <bundle> b, где a, b также могуть быть формулами.

Используем рекурсивный подход, и для начала решим задачу для базы рекурсии, когда a, b - какие-то атомарные выражения.

Далее поднимаемся по дереву, смотрим, что выходит с формулой, и доказываем то, что получается, не пытаемся сделать невозможного (доказать что из !a и !b следует a&b, а наоборот, доказываем что из этого следует !a&b). Также одной из оптимизацией следует использовать ленивые вычисления: для некоторых операторов (таких как &, |, ->) можно доказать, что если одна часть принимает какое-то значение, то и остальное выражение будет иметь какое-то фиксированное значение. И это следует использовать при сдачи данной лабораторной. Притом следует вычислять наименьшую по глубине формулу.

Для построения доказательства нам придётся руками придумать все переходы (на что ушло порядочно времени) и прописать их явно в коде, увы и ах, код за нас не сможет построить доказательство вообще всего.

За остальными подробностями - в код

### 5 задача
Гроб, я серьёзно.
Решается также рекурсивно, нужно найти некоторое правило того, как выносит кванторы на 1 позицию вверх, как они взаимодействуют друг с другом, что звучит просто, однако под лежит ~16 камней, а точнее доказательств переходов, которые нужно построить.
Удачи)
